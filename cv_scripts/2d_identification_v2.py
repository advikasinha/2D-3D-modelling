# -*- coding: utf-8 -*-
"""2D-identification-v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MtPDm9KwJExnqXUwaekkZ79bA_whEZyI

## Dimensioning function

The following funtion is used for dimensioning step, where you have to provide the all the 3 views images and the output of this function will be the image highlighted with a line and the unit length to pixel value. Once you get the raito value you can multiple it with the length of the highlighted line to get the length to pixel ratio for that view.
"""

import copy
import json
import os
import shutil
import cv2
import numpy as np
from matplotlib import pyplot as plt
from IPython.display import Image
from google.colab.patches import cv2_imshow
from google.colab import files

uploaded = files.upload()

for fname in uploaded.keys():
    image_path = fname

img = cv2.imread(image_path)
orig = img.copy()
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)

# Find contours
contours, hierarchy = cv2.findContours(thresh, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)
hierarchy, contours = zip(*sorted(zip(hierarchy[0], contours), key=lambda x: cv2.contourArea(x[1]), reverse=True))

shapes_detected = []

# Iterate and detect shape + dimensions
for i, c in enumerate(contours):
    if hierarchy[i][3] != -1 or (hierarchy[i][3] == -1 and hierarchy[i][2] == -1):
        M = cv2.moments(c)
        if M["m00"] != 0:
            cX = int(M["m10"] / M["m00"])
            cY = int(M["m01"] / M["m00"])
            rect = cv2.minAreaRect(c)
            box = cv2.boxPoints(rect)
            box.astype(int)
            x, y, w, h = cv2.boundingRect(c)

            # Approximate shape
            peri = cv2.arcLength(c, True)
            approx = cv2.approxPolyDP(c, 0.04 * peri, True)
            num_vertices = len(approx)
            shape = "unidentified"

            if num_vertices == 3:
                shape = "triangle"
            elif num_vertices == 4:
                aspect_ratio = w / float(h)
                shape = "square" if 0.95 <= aspect_ratio <= 1.05 else "rectangle"
            elif num_vertices == 5:
                shape = "pentagon"
            elif num_vertices > 5:
                shape = "circle"

            cv2.drawContours(orig, [box], 0, (0, 0, 255), 2)
            cv2.putText(orig, f"{shape} {w}x{h}", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
            shapes_detected.append((shape, w, h))
            break  # only the biggest outer shape for this demo

cv2_imshow(orig)
plt.title("Detected Shape and Dimensions")
plt.show()

print("\nShapes Detected (Shape, Width, Height):")
for s in shapes_detected:
    print(s)

import cv2
import numpy as np

def preprocess(img_path):
    img = cv2.imread(img_path)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # Invert for black lines on white
    gray = 255 - gray
    # Adaptive thresholding works better for thin lines
    thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                   cv2.THRESH_BINARY, 11, 2)
    # Optional: Dilate to strengthen thin lines
    kernel = np.ones((2,2), np.uint8)
    dilated = cv2.dilate(thresh, kernel, iterations=1)
    return dilated

def preprocess_with_canny(img_path):
    img = cv2.imread(img_path)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    edges = cv2.Canny(gray, 50, 150, apertureSize=3)
    # Optional: Dilate to close gaps
    kernel = np.ones((2,2), np.uint8)
    edges = cv2.dilate(edges, kernel, iterations=1)
    return edges

def detect_shapes(processed_img):
    contours, _ = cv2.findContours(processed_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    shapes = []
    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area < 100:  # Ignore tiny contours
            continue
        epsilon = 0.02 * cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, epsilon, True)
        if len(approx) == 4:
            shape = "rectangle"
            shapes.append({
                "contour": approx,
                "type": shape,
                "bbox": cv2.minAreaRect(cnt)
            })
    return shapes

def analyze_orthographic_views(front, top, side):
    front_shapes = detect_shapes(preprocess(front))
    top_shapes = detect_shapes(preprocess(top))
    side_shapes = detect_shapes(preprocess(side))

    # Check for empty results
    if not front_shapes:
        raise ValueError("No shapes detected in front view")
    if not top_shapes:
        raise ValueError("No shapes detected in top view")
    if not side_shapes:
        raise ValueError("No shapes detected in side view")

    # Get largest contour per view
    main_front = max(front_shapes, key=lambda x: cv2.contourArea(x['contour']))
    main_top = max(top_shapes, key=lambda x: cv2.contourArea(x['contour']))
    main_side = max(side_shapes, key=lambda x: cv2.contourArea(x['contour']))

    projected_dims = {
        'length': main_front['bbox'][1][0],  # width of front view bounding rect
        'width': main_top['bbox'][1][0],     # width of top view bounding rect
        'height': main_side['bbox'][1][1]    # height of side view bounding rect
    }

    return projected_dims

def pixel_to_real(pixel_dims, reference_length, reference_pixels):
    scale_factor = reference_length / reference_pixels
    return {
        'length': pixel_dims['length'] * scale_factor,
        'width': pixel_dims['width'] * scale_factor,
        'height': pixel_dims['height'] * scale_factor
    }

# Input paths
front_view = "/content/front.jpg"
top_view = "/content/top.jpg"
side_view = "/content/side.jpg"

# Process images
pixel_dims = analyze_orthographic_views(front_view, top_view, side_view)

# Convert to real dimensions (using known 100mm reference = 200px)
real_dims = pixel_to_real(pixel_dims, reference_length=100, reference_pixels=200)

print(f"3D Dimensions: {real_dims}")

img = cv2.imread('/content/front.jpg')
processed = preprocess('/content/front.jpg')
contours, _ = cv2.findContours(processed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(img, contours, -1, (0,255,0), 2)
cv2_imshow( img)
cv2.waitKey(0)
cv2.destroyAllWindows()

from google.colab.patches import cv2_imshow

import cv2
import numpy as np

# --- 1. Preprocess the image ---
def preprocess(img_path):
    img = cv2.imread(img_path)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # Invert image for black lines on white
    gray = 255 - gray
    # Adaptive threshold to handle thin lines
    thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                   cv2.THRESH_BINARY, 11, 2)
    # Dilate to thicken lines
    kernel = np.ones((2,2), np.uint8)
    dilated = cv2.dilate(thresh, kernel, iterations=1)
    return dilated, img

# --- 2. Detect rectangle contour ---
def detect_rectangle(processed_img):
    contours, _ = cv2.findContours(processed_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area < 100:  # Ignore tiny contours
            continue
        epsilon = 0.02 * cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, epsilon, True)
        if len(approx) == 4:
            return approx  # Found rectangle
    return None

# --- 3. Run the detection and visualize ---
processed, original = preprocess('/content/front.jpg')
rectangle = detect_rectangle(processed)

if rectangle is not None:
    cv2.drawContours(original, [rectangle], -1, (0,255,0), 2)
    cv2_imshow( original)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    print("Rectangle detected! Coordinates:", rectangle.reshape(-1, 2))
else:
    print("No rectangle detected. Try adjusting dilation or threshold parameters.")

# --- 3. Run the detection and visualize ---
processed, original = preprocess('/content/top.jpg')
rectangle = detect_rectangle(processed)

if rectangle is not None:
    cv2.drawContours(original, [rectangle], -1, (0,255,0), 2)
    cv2_imshow( original)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    print("Rectangle detected! Coordinates:", rectangle.reshape(-1, 2))
else:
    print("No rectangle detected. Try adjusting dilation or threshold parameters.")

# --- 3. Run the detection and visualize ---
processed, original = preprocess('/content/side.jpg')
rectangle = detect_rectangle(processed)

if rectangle is not None:
    cv2.drawContours(original, [rectangle], -1, (0,255,0), 2)
    cv2_imshow( original)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    print("Rectangle detected! Coordinates:", rectangle.reshape(-1, 2))
else:
    print("No rectangle detected. Try adjusting dilation or threshold parameters.")

